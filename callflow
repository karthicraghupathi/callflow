#!/bin/bash
###
###  CallFlow diagram generator
###
###  Usage:  callflow.sh capture-file | -t text-input file
###
###  Output: $DESTDIR/callflow.svg, $DESTDIR/callflow.png, $DESTDIR/index.html, $DESTDIR/frames/frame*.html
###
###

##################################
# Variables
##################################
CONFDIR="/etc/callflow";
removeDF=0 # do not remove duplicate frames
ORDER=0 # do not build order file
localLoop=1 # take into account flows from and to the same element (rounded flows)
readonly VersionSVN="$Id$"; #DO NOT EDIT THIS LINE BY HAND, DATE IS AUTOMATICALLY ADDED BY SUBVERSION
readonly PRGVRSN=$(awk '{split($4, A, "-"); print A[1] A[2] A[3] "." $3}' <<< "$VersionSVN")
readonly PRGNAME=$(basename $0)

# Define exit values
readonly ERR_ARGUMENT=2

##################################
# Check configuration files :
#   callflow.conf, order, colors
##################################
for CONF in $CONFDIR/callflow.conf $HOME/.callflow/callflow.conf callflow.conf; do
  [[ -f $CONF ]] && . $CONF
done

# Basic conf
[[ -z "$SETUPDIR" ]] && SETUPDIR="/usr/local/callflow"
[[ -z "$TMPDIR" ]] && TMPDIR="/tmp"

[[ ! -d $SETUPDIR ]] && {
  ( echo "$PRGNAME: error: setup directory \"$SETUPDIR\" does not exist"
    echo "Adjust your configuration"
  ) >&2
  exit 1
}

[[ ! -d $TMPDIR ]] && {
  ( echo "$PRGNAME: error: temporary directory \"$TMPDIR\" does not exist"
    echo "Adjust your configuration"
  ) >&2
  exit 1
}

if [[ -z "$FILTER" ]]; then
  FARG=""
  FVAL=""
else
  FARG="-R"
  FVAL="$FILTER"
fi

if [[ -f colors ]]; then
  COLORS=$(cat colors)
fi

[[ -z "$COLORS" ]] && {
  # At least one color is needed, to prevent errors
  COLORS="black"
}

function make_long_and_short_caches() {

  tshark -r $inputfile $FARG "$FVAL" -V > $DESTDIR/callflow.long

  # Create a datafile with the data needed to create the callflow.
  # This is done in 2 steps, because of the following reasons:  the tshark command
  # with the '-T fields' argument, provides the IP addresses and SIP CSeq and Call-ID
  # data.  Some additional information about the Call-ID; this field can show up
  # in (at least) 2 ways in SIP messages.  The field can indeed be called "Call-ID",
  # but just "i" in abbreviated SIP messages!  Both formats can be used in 1 call.
  tshark -r $inputfile $FARG "$FVAL" -t a -T fields -E separator='|' \
    -e frame.number -e ip.src -e ip.dst -e sip.CSeq -e sip.Call-ID | awk '
  BEGIN {
    FS = "|"
    OFS = "|"
    NOC = 1 # Number Of Call-IDs
  }
  {
    # Map the often very long Call-IDs to a short index, with only 1 or 2 digits
    if (( $5 != "" ) && ( CALLID[$5] == "" )) {
      CALLID[$5] = NOC
      NOC++
    }
      
    printf "%s||%s|%s|%s|{%s}\n", $1, $2, $3, $4, CALLID[$5]

  }' > $TMPDIR/${PRGNAME}-tshark-1.$$

  # The second step in getting SIP data required by callflow.  This step delivers
  # the source and destination ports independent whether the datagram is UDP or
  # TCP based.  As SIP can be delivered over UDP or TCP using this tshark command
  # seems to be good choice.  Further more this command delivers the frame information
  # (summary), that can not be obtained with tshart '-T fields' command above.
  #
  # For messages containing ISUP payload this step could deliver the IP addresses
  # when using % variables %ns and %nd (network source and destination).  If the
  # % variables %s and %d are used the highest source and destination addresses are
  # used, in case of ISUP message that are the OPC and DPC data, for details see
  # wireshark bug 5969.
  #
  # The available % variables can be found at:
  #   http://anonsvn.wireshark.org/viewvc/trunk/epan/column.c?view=markup
  #
  # Information about the stream editor (sed) manipulations:
  # - The string (ITU) shows up in the protocol description "ISUP(ITU)".
  #   awk doesn't like the "(" and ")", hence remove them.
  # - Short the string "with session description" to just SDP.
  # - Megaco has a "|" in its info sting, this character is however the
  #   field separator in the output file, remove it.  The actual string
  #   being removed is " |=".
  tshark -r $inputfile $FARG "$FVAL" -t a \
    -o 'column.format: "No.", "%m", "Time", %t, "Protocol", "%p", "srcport", %S, "dstport", %D, "Info", "%i"' |
      sed -e 's/^[[:blank:]]*//' \
        -e 's/[[:blank:]]*|=/=/' \
        -e 's/ Status: / /' \
        -e 's/ Request: / /' \
        -e 's/(ITU)//' \
        -e 's/with session description/SDP/g' | awk '{

    split($0, A, " ")

    for (i = 1; i <= 5; i++) {
      printf "%s|", $i
    }

    L = length(A)
    for (i = 6; i < L; i++) {
      printf "%s ", $i
    }

    printf "%s\n", $L

  }' > $TMPDIR/${PRGNAME}-tshark-2.$$
    
  # Join the 2 datafiles that have been obtained above together
  join -t "|" --nocheck-order $TMPDIR/${PRGNAME}-tshark-1.$$ $TMPDIR/${PRGNAME}-tshark-2.$$ > $TMPDIR/${PRGNAME}-tshark-3.$$

  # Order the fields
  awk 'BEGIN {
    FS = "|"

    # The order in which the fields will be arranged in the output file
    # 1: time
    # 2: tracefile
    # 3: frame.number
    # 4: ip.src
    # 5: ip.srcport 
    # 6: session information
    # 7: ip.dst
    # 8: ip.dstport
    # 9: protocol
    # 10: info field
    # 11: SIP CSeq

    # The array (A) that the 'split' command creates, maps the input fields
    # to the output file order.  As example: input field 7 is mapped to
    # output field 1 and input field 5 is mapped to output field 11.
    split("7 2 1 3 9 6 4 10 8 11 5", A, " ")
  }
  {
    # Look for "200 OK" or "200 Ok" and add the SIP method, from the
    # call sequence field to the 200 OK message.
    #
    # Attention: use the input fields values and not the ones mentioned in
    # the BEGIN part.
    # - $5 contains the sip.CSeq data.
    # - $8 contains the protocol
    # - $11 contains the info field data.
    if (($8 ~ "SIP") && ($11 ~ "200 O")) {
      # split the call sequence message (#ID SIP_method)
      split($5, S, " ")
      $11 = sprintf("%s (%s)", $11, S[2])
    }

    # Perform the actual mapping of the input to the output fields
    L = length(A)
    for (i = 1; i < L; i++) {
      printf "%s|", $A[i]
    }

    printf "%s\n", $A[L]

  }' $TMPDIR/${PRGNAME}-tshark-3.$$ > $DESTDIR/callflow.short

  rm $TMPDIR/${PRGNAME}-tshark-[123].$$

  TRACE_FILE=$(basename $inputfile)
  MD5SUM=$(md5sum $inputfile | awk '{print $1}')
  echo "$TRACE_FILE|$MD5SUM|$FVAL" > $DESTDIR/metadb
}

function usage() {

  ( echo "$SHORTHELP"
    echo "See $PRGNAME --help for extended help."
  ) >&2
  exit 0
}

function help () {

  cat << EOF >&1
Usage: $PRGNAME [options] <trace file>

Options:
   -h           Print short help and exit
  --help        Print this help and exit
  --version, -v Print version

  --capture-filter <filter>, -f <filter>
                A filter can be used to show only those frames that match the
                given filter criteria.  This filter is for traces that have been
                captured with programs such as wireshark, snoop, tcpdump, tshark
                and the like.  $PRGNAME uses tshark's DISPLAY filter functionality
                to filter the trace.  More information about tshark's DISPLAY
                filter can be obtained from the tshark man page.
                A useful filter for SIP traffic is "sip".

  --list-nodes, -o
                List the unique nodes in the trace file
                (Don't forget to redirect output in another file.
                 Example of use: $PRGNAME --list-nodes capture.cap > order)

  --no-loops
                Prevent flows from and to the same equipment to be represented.

  --no-time
                Do not show the time.

  --nodenames
                A file containing the element or node names that belong to the
                addresses shown in the callflow.

  --refresh-cache
                Refresh the contents of the callflow.short and callflow.long
                files.  By default these are cached.  The cache is automatically
                refreshed, when a changed input file, or a different filter is
                is used.

  --remove-duplicate-frames, -d
                Remove duplicate frames while computing.
                This option should not be selected on the first run.

  --title <title>
                Use <title> as title in the callflow.  If not specified the
                name of file containing the trace will be used instead. Surround
                <title> by quotes in case the title contains spaces or tabs.

  --width-between-nodes <width>
                Distance between adjacent nodes in final picture.  The width may
                vary between 100 and 250.  Default = 200.

EOF
}

readonly SHORTHELP="Usage: $PRGNAME [options] <filename>" 

# Command line argument parsing, the allowed arguments are
# alphabetically listed, keep it this way please.
LOPT="capture-filter:,help,list-nodes,no-loops,no-time,nodenames:,refresh-cache"
LOPT="$LOPT,remove-duplicate-frames,title:,width-between-nodes:,version"

# Note that we use `"$@"' to let each command-line parameter expand to a
# separate word. The quotes around `$@' are essential!
# We need TEMP as the `eval set --' would nuke the return value of getopt.
TEMP=$(getopt --options=dfhorv --long $LOPT -n $PRGNAME -- "$@")

if [[ $? -ne 0 ]]; then
  echo "Terminating..." >&2
  exit $ERR_ARGUMENT
fi

# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"

while true; do
  case $1 in
  --help)                help; exit ;;
   -h)                   usage; exit;;

  --capture-filter|-f)
                         # Overwrite the default filter previously red from the configuration file
                         OPT_FILTER=$2; shift
                         #echo " * Will use the following filter: $OPT_FILTER"
                         ;;
  --list-nodes|-o)
                         ORDER=1
                         ;;
  --no-loops)
                         # We want to disable auto flows (From and To the same equipment)
                         noLocalLoop=1;
                         #echo " * Flows from and to the same equipment will not be shown"
                         ;;
  --no-time)
                         OPT_SHOW_TIME=no
                         #echo " * Time will not be shown"
                         ;;
  --nodenames)
                         OPT_NODENAMES=$2; shift
                         ;;
  --refresh-cache)
                         OPT_REFRESH_CACHE=yes
                         ;;
  --remove-duplicate-frames|-d)
                         # Remove duplicate frames
                         removeDF=1
                         #echo " * Duplicate frames will be removed"
                         ;;
  --title)
                         OPT_TITLE="$2"; shift
                         #echo " * Title to use: $OPT_TITLE"
                         ;;
  --width-between-nodes)
                         OPT_WIDTH_BETWEEN_NODES=$2; shift
                         #echo " * Width between nodes to use: $OPT_WIDTH_BETWEEN_NODES"
                         ;;
  --version|-v)          echo "$PRGNAME version: $PRGVRSN"; exit;;
  --)                    shift; break;;
   *)                    echo "unknow argument \"$1\""; exit $ERR_ARGUMENT;;
  esac
  shift
done

inputfile=$1

##################################
# Check input file
##################################
if [ ! -f "$inputfile" ]; then 
  echo "$PRGNAME: error: Input file ($inputfile) does not exists!"
  exit 1;
fi

##################################
# Configuration file overwritting by command line options
##################################
if [[ ! -z "$OPT_FILTER" ]]; then
  if [[ "$OPT_FILTER" == "" ]]; then
    FARG=""
    FVAL=""
  else
    FARS="-R"
    FVAL="$OPT_FILTER"
  fi
fi

if [[ -z "$OPT_WIDTH_BETWEEN_NODES" ]]; then
  WIDTH_BETWEEN_NODES=200
else
  if [[ $OPT_WIDTH_BETWEEN_NODES -gt 250 ]]; then
    echo "$PRGNAME: error: width between nodes too big" >&2
    exit 1
  fi

  if [[ $OPT_WIDTH_BETWEEN_NODES -lt 100 ]]; then
    echo "$PRGNAME: error: width between nodes too small" >&2
    exit 1
  fi

  WIDTH_BETWEEN_NODES=$OPT_WIDTH_BETWEEN_NODES
fi

[[ -n "$OPT_NODENAMES" ]] && {
  if [[ -f "$OPT_NODENAMES" ]]; then
    NODENAMES="$OPT_NODENAMES"
  else
    echo "$PRGNAME: error: nodenames file does not exist (--nodenames)" >&2
    exit 1
  fi
}

if [[ -z "$OPT_SHOW_TIME" ]]; then
  SHOW_TIME=yes
else
  SHOW_TIME=$OPT_SHOW_TIME
fi

if [[ -n "$OPT_TITLE" ]]; then
  TITLE="$OPT_TITLE"
else
  TITLE="$inputfile"
fi

# DESTDIR
DESTDIR=`ls $inputfile | sed -r "s/(.+)\.(.+)/\1/"`;
mkdir -p $DESTDIR

# Use cache?
if [[ "$OPT_REFRESH_CACHE" == "yes" ]]; then
  USE_CACHE=no
else
  if [[ -f $DESTDIR/metadb ]]; then
    if [[ -f $DESTDIR/callflow.short ]]; then
      FILE=$(basename $inputfile)
      MD5_FILE=$(md5sum $inputfile | awk '{print $1}')

      MD5_CACHE=$(awk -F"|" -v FILE=$FILE '{if ($1 == FILE) {print $2} }' $DESTDIR/metadb)

      if [[ $MD5_FILE == $MD5_CACHE ]]; then

        # Are the cached filter and used filter the same?
        CACHED_FILTER=$(awk -F"|" -v FILE=$FILE '{if ($1 == FILE) {print $3} }' $DESTDIR/metadb)

        if [[ "$FVAL" == "$CACHED_FILTER" ]]; then
          USE_CACHE=yes
        else
          USE_CACHE=no
        fi
      else
        # The input file changed
        USE_CACHE=no
      fi
    else
      # The file $DESTDIR/callflow.short does not exist
      USE_CACHE=no
    fi
  else
    # The file $DESTDIR/metadb does not exist
    USE_CACHE=no
  fi
fi

##################################
# order file
##################################
# Build the order file and exit
[[ -z "$NODENAMES" ]] && {
  for FILE in $HOME/.callflow/nodenames.conf nodenames.conf; do
    if [[ -f $FILE ]]; then
      NODENAMES=$FILE
    fi
  done
}

if [[ $ORDER = 1 ]]; then

  [[ $USE_CACHE == "no" ]] && make_long_and_short_caches

  awk -f $SETUPDIR/scripts/list-nodes.awk -v NODENAMES=$NODENAMES $DESTDIR/callflow.short

  exit 0
fi

if [[ -f order ]]; then
  orderFile=order
elif [[ -f $DESTDIR/order ]]; then
  orderFile=$DESTDIR/order
else
  orderFile=none
fi

##################################
# Build short and long files
##################################
# Copy the input file into destdir
TRACEFILE=$(basename $inputfile)
cp $inputfile $DESTDIR/$TRACEFILE

# if we do want to build new short and long file
if [[ $USE_CACHE == "no" ]]; then

  make_long_and_short_caches

fi

# We have to check if short and long file exist
if [ ! -f $DESTDIR/callflow.long ]; then
  echo "$PRGNAME: error: File callflow.long does not exist!"
  exit 1;
else
  # Some SIP messages don't include a space between the Call-ID tag and
  # Call-ID value
  sed -i 's,\(Call-ID:\)\([^ ]\),\1 \2,' $DESTDIR/callflow.long
fi

if [ ! -f $DESTDIR/callflow.short ]; then
  echo "$PRGNAME: error: File callflow.short does not exist!"
  exit 1;
else
  # Remove Malformed packages from callflow.short, especially because it
  # contains unpaired "["
  sed -i '/Malform/d' $DESTDIR/callflow.short
fi

# Create Frames
mkdir -p $DESTDIR/frames
awk -f $SETUPDIR/scripts/long2html.awk -v destDir=$DESTDIR < $DESTDIR/callflow.long
for FILE in $SETUPDIR/css/callflow.css $HOME/.callflow/callflow.css callflow.css; do
  [[ -f $FILE ]] && STYLESHEET=$FILE
done
cp $STYLESHEET $DESTDIR/frames

# Remove duplicate Frame
if [ $removeDF = 1 ]; then
  #echo "Removing duplicate frames"
  $SETUPDIR/scripts/removedups.sh $DESTDIR $DESTDIR/frames $TMPDIR ${REMOVE_DUP_MODE:-REMOVE_ALL_DUPS}
  rm $DESTDIR/callflow.short
  mv $DESTDIR/callflow.short.new $DESTDIR/callflow.short
fi

##################################
# common
##################################
# Compute nodes
awk -f $SETUPDIR/scripts/list-nodes.awk -v NODENAMES=$NODENAMES \
  $DESTDIR/callflow.short > $TMPDIR/callflow.auto-uniq.$PPID

# orderFile
if [ $orderFile != none ]; then
    # add forced nodes
    cp $TMPDIR/callflow.auto-uniq.$PPID $TMPDIR/callflow.auto-uniq-forced.$PPID
    grep "!f!" $orderFile | cut -d " " -f 1 >> $TMPDIR/callflow.auto-uniq-forced.$PPID
    cut -d " " -f 1 < $orderFile > $TMPDIR/callflow.order-nodes.$PPID

    # prune nodes not appearing in capture file and not forced.
    grep -w -v -f $TMPDIR/callflow.auto-uniq-forced.$PPID $TMPDIR/callflow.order-nodes.$PPID > $TMPDIR/callflow.prune-candidate.$PPID
    awk -f $SETUPDIR/scripts/makevars.awk < $TMPDIR/callflow.prune-candidate.$PPID > $TMPDIR/callflow.prune-vars.$PPID
    cat $TMPDIR/callflow.prune-vars.$PPID $SETUPDIR/scripts/prunenodes.awk > $TMPDIR/callflow.prune-awk.$PPID
    awk -F"|" -f $TMPDIR/callflow.prune-awk.$PPID < $DESTDIR/callflow.short > $TMPDIR/callflow.auto-not-pruned.$PPID
    grep -w -v -f $TMPDIR/callflow.auto-not-pruned.$PPID $TMPDIR/callflow.prune-candidate.$PPID > $TMPDIR/callflow.auto-prune.$PPID
    grep -w -v -f $TMPDIR/callflow.auto-prune.$PPID $TMPDIR/callflow.order-nodes.$PPID > $TMPDIR/callflow.order-nodes-pruned.$PPID

    # add nodes appearing in capture file but not in order file
    cp $TMPDIR/callflow.order-nodes-pruned.$PPID $TMPDIR/callflow.order-nodes-final.$PPID
    grep -w -f $TMPDIR/callflow.auto-uniq-forced.$PPID $TMPDIR/callflow.order-nodes.$PPID >> $TMPDIR/callflow.order-nodes-final.$PPID
    grep -w -f $TMPDIR/callflow.order-nodes-final.$PPID $orderFile > $TMPDIR/callflow.order.$PPID
    grep -w -v -E -f $TMPDIR/callflow.order-nodes.$PPID $TMPDIR/callflow.auto-uniq-forced.$PPID >> $TMPDIR/callflow.order.$PPID
    sed "s/!f!//g" < $TMPDIR/callflow.order.$PPID > $TMPDIR/callflow.order-final.$PPID

    finalOrderFile=$TMPDIR/callflow.order-final.$PPID

    #echo Using the following order:
    #cat $finalOrderFile
else
    echo "$PRGNAME: warning: no \"order\" file found -- using auto generated"
    finalOrderFile=$TMPDIR/callflow.auto-uniq.$PPID
fi

( awk -f $SETUPDIR/scripts/makevars.awk $finalOrderFile

  cat << AWK_BEGIN_SECTION

  title = "$TITLE"

  # Add graph variables
  yLineSpace = 24
  xHostSpace = $WIDTH_BETWEEN_NODES
  rightMargin = 100
  topMargin = 50
  bottomMargin = 50
  showTime = "$SHOW_TIME"
  if ( showTime == "yes" ) {
    leftMargin = 120
  } else {
    leftMargin = 50
  }
  numTraces = numHosts

  # Add localLoop to vars in order to delete self messaging
  localLoop = "$localLoop"

AWK_BEGIN_SECTION

  echo "numLines = $(cat $DESTDIR/callflow.short | wc -l)"
  echo

  # Add colors from colorFile
  awk 'BEGIN { I = 0} {
    for (N = 1; N <= NF; N++) {
      printf("  color[%d] = \"%s\"\n", I++, $N)
    }
  } END {
    print "  colors = length(color) - 1"
  }' <<< "$COLORS"

  echo
  cat $SETUPDIR/scripts/callflow.awk

) > $TMPDIR/callflow.awk.$PPID

# Build callflow.svg
awk -F "|" -f $TMPDIR/callflow.awk.$PPID $DESTDIR/callflow.short > $DESTDIR/callflow.svg

# Remove temporary files
\rm $TMPDIR/callflow.*.$PPID

# Build callflow.png if inkscape is available
if which inkscape >/dev/null 2>&1; then
  inkscape --export-dpi=90 -C --export-background=white --export-png=$DESTDIR/callflow.png $DESTDIR/callflow.svg

  # Build HTML files
  # Frameless; (SIP) messages will be presented in the same window as the callflow picture
  ( echo "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\""
    echo "  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">"
    echo "<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">"
    echo " <head>"
    echo "  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>"
    echo "  <title>$PRGNAME - $TITLE</title>"
    echo "  <style type=\"text/css\">"
    echo ".callflow-image img {"
    echo " display: block;"
    echo " border: 0px;"
    echo " margin-left: auto;"
    echo " margin-right: auto;"
    echo "}"
    echo "  </style>"
    echo " </head>"
    echo " <body>"
    echo "  <div class=\"callflow-image\">"
    cat imagemap
    echo "   <p>"
    echo "    <img src=\"callflow.png\" usemap=\"#callflowmap\" alt=\"Call flow sequence diagram for $inputfile\"/>"
    echo "   </p>"
    echo "   <p>"
    echo "    <a href=\"$TRACEFILE\">Trace source</a>"
    echo "   </p>"
    echo "  </div>"
    echo " </body>"
    echo "</html>"
  ) > $DESTDIR/index_frameless.html
   
  # (SIP) Messages will be presented in popups on the callflow picture
  ( echo "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\""
    echo "  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">"
    echo "<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">"
    echo " <head>"
    echo "  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>"
    echo "  <title>$PRGNAME - $TITLE</title>"
    echo "  <style type=\"text/css\">"
    echo ".callflow-image img {"
    echo " display: block;"
    echo " border: 0px;"
    echo " margin-left: auto;"
    echo " margin-right: auto;"
    echo "}"
    echo "  </style>"
    echo "  <script type=\"text/javascript\" src=\"js/overlib.js\"></script>"
    echo "  <script type=\"text/javascript\" src=\"js/callflow.js\"></script>"
    echo " </head>"
    echo " <body>"
    echo "  <div class=\"callflow-image\">"
    cat imagemap
    echo "   <p>"
    echo "    <img src=\"callflow.png\" usemap=\"#callflowmap\" alt=\"Call flow sequence diagram for $inputfile\"/>"
    echo "   </p>"
    echo "   <p>"
    echo "    <a href=\"$TRACEFILE\">Trace source</a>"
    echo "   </p>"
    echo "  </div>"
    echo " </body>"
    echo "</html>"
  ) > $DESTDIR/index_dynamic.html
   
  #Copy JavaScript files into DESTDIR
  cp -af $SETUPDIR/js $DESTDIR/


  # (SIP) Messages will be presented in right frame
  sed 's/coords=/target=\"msg\" coords=/' $DESTDIR/index_frameless.html > $DESTDIR/graph.html

  firstFrame=$(awk -F "|" '{ if (NR == 1) print $3 }' $DESTDIR/callflow.short)

  ( echo "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\""
    echo "   \"http://www.w3.org/TR/html4/frameset.dtd\">"
    echo "<html>"
    echo " <head>"
    echo "  <meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\" >"
    echo "  <title>$PRGNAME - $TITLE</title>"
    echo " </head>"
    echo " <frameset cols=\"75%,25%\">"
    echo "  <frame name=\"graph\" src=\"graph.html\">"
    echo "  <frame name=\"msg\" src=\"frames/Frame${firstFrame}.html\">"
    echo " </frameset>"
    echo "</html>"
  ) > $DESTDIR/index_frame_right.html

  # (SIP) Messages will be presented in bottom frame
  sed 's/cols=/rows=/' $DESTDIR/index_frame_right.html > $DESTDIR/index_frame_bottom.html

  mkdir -p $DESTDIR/images
  cp -a $SETUPDIR/images/*png $DESTDIR/images
  sed "s/@TITLE@/$PRGNAME - $TITLE/;s/@TRACE@/$inputfile/" \
    $SETUPDIR/images/index.tpl > $DESTDIR/index.html

else
  ( echo "Error $PRGNAME: inkscape not found."
    echo "The Scalable Vector Graphic (.svg) has been made, but no"
    echo "Portable Network Graphic (.png) can be created."
    echo "Install inkscape, to enjoy all that $PRGNAME can give to you!"
  ) >&2
  
  exit 1
fi

echo
echo "The output can be viewed with a browser: "
echo " ${BROWSER:=firefox} $DESTDIR/index.html"

\rm imagemap
exit 0;

